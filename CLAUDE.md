# zip-rs 开发规范

## SPEC 位置

- **测试策略**: [SPEC/06-TESTING-STRATEGY.md](SPEC/06-TESTING-STRATEGY.md) - 完整复刻 C 版本测试用例

## 项目概述

zip-rs 是 zip R 包的 Rust 版本，功能完全对等。

## 开发铁律

### 1. C 版本优先原则（铁律 - 最高优先级）

> **⚠️ 遇到任何问题从C版本找答案，它是权威实现，必然能给出答案！**

遇到错误和问题时，**必须优先查看 C 版本对应代码**（`../src/miniz.c`、`../src/zip.c`、`../src/rzip.c`）：

| 问题类型 | 参考位置 |
|---------|---------|
| 算法逻辑错误 | `../src/miniz.c` 对应函数 |
| 测试期望值 | 运行 C 版本验证正确值 |
| 数据结构 | 对比 C 版本结构定义 |
| 边界条件 | 参考 C 版本处理方式 |
| 符号链接处理 | `../src/zip.c` 的 `zip_unzip()` 函数 |
| 时间戳转换 | `../src/miniz.c` 的 `mz_zip_dos_to_time_t()` |
| 外部属性 | `../src/miniz.c` 的 `mz_zip_reader_file_stat()` |
| 压缩级别 | `../src/miniz.c` 的 `tdefl_compress()` |

### 2. 测试严格对等原则（铁律 - 绝对禁止违反）

**⚠️ 测试用例应该与 C 版本完全一样，绝对不准改！**
**⚠️ 如果测试没有通过，那就是我们代码实现问题，不是测试问题！**

**⚠️ 禁止作弊行为（铁律 - 绝对禁止）**：
- ❌ 修改测试期望值来适配实现（**作弊行为**）
- ❌ 使用 `cargo insta test --accept` 强制接受新快照
- ❌ 跳过失败的测试
- ❌ 降低测试标准
- ❌ 修改快照文件来让测试通过

**✅ 正确做法**：
- 如果测试失败，说明**代码实现有 bug**
- 必须**修复代码**，让测试通过
- 如果怀疑旧测试期望值错误，必须**用 C 版本验证**
- 用 Python/标准工具验证正确值
- 确认无误后，才考虑更新测试（需谨慎）

**测试快照更新原则**：
1. **默认禁止更新快照** - 快照是基于 C 版本的真实值
2. **例外情况**（需同时满足）：
   - 旧快照基于**错误的 FFI 实现**
   - 用 C 版本/Python 验证确认新值正确
   - 文档化为什么旧值是错误的

**⚠️ 纯 Rust 实现原则（铁律）**：
- **测试实现**: 纯 Rust 代码，禁止 FFI 调用 C 函数
- **验证方式**: 通过字节级输出对比验证一致性
- **FFI 测试**: 已删除 `tests/ffi/` 目录，改用纯 Rust 实现

| 行为 | 是否允许 |
|-----|---------|
| ❌ 修改测试期望值来适配实现 | **绝对禁止** |
| ❌ 跳过失败的测试 | **绝对禁止** |
| ❌ 降低测试标准 | **绝对禁止** |
| ❌ 使用 FFI 调用 C 函数验证 | **绝对禁止**（已废除） |
| ✅ 修复代码实现使测试通过 | **唯一正确做法** |
| ✅ 使用 Python/zlib 验证期望值 | **推荐做法** |
| ✅ 参考 C 版本实现 | **必须做法** |
| ✅ 纯 Rust 实现测试用例 | **必须做法** |

**验证标准**：
- Rust 版本必须 100% 通过 C 版本相同的所有测试用例
- 测试失败 = 代码实现有 bug，需要修复代码，不能修改测试
- 每个功能必须有对应测试
- 测试文件与 C 版本一一对应（详见 SPEC/06-TESTING-STRATEGY.md）

### ⚠️ 测试验收铁律（绝对禁止违反）

> **目前的测试用例必须确保与C版本使用的100%行为、特性、逻辑、数据全部一致！视它为验收守门员！**

**含义**：
- 测试用例是**验收守门员**，是判断实现正确的唯一标准
- 100%一致性要求：行为一致、特性一致、逻辑一致、数据一致
- 任何偏差都意味着实现有bug，必须修复代码，不能修改测试

**禁止行为**：
- ❌ "差不多就行" - 99%一致 = 0分
- ❌ "Rust惯用法不同" - 不是借口
- ❌ "性能优化导致的差异" - 必须行为一致
- ❌ "边界条件处理不同" - 必须完全一致

### ⚠️ 禁止用外部库替代实现（铁律 - 绝对禁止违反）

> **禁止使用外部库替代C版本项目内实现的功能来偷懒！**

**含义**：
- C版本自己实现的功能（如miniz.c的DEFLATE压缩），Rust版本也必须自己实现
- 禁止用现成的库（miniz_oxide、flate2、libz等）替代自己实现
- 这是重写项目，不是包装项目

**明确禁止**：
- ❌ 用miniz_oxide替代DEFLATE压缩实现
- ❌ 用flate2替代压缩/解压缩功能
- ❌ 用其他CRC32/Adler32库替代自己实现
- ❌ 用外部哈希库替代自己实现
- ❌ 任何形式"用库省事"的做法

**正确做法**：
- ✅ 参考C版本的实现逻辑（miniz.c、zip.c等）
- ✅ 用Rust重新实现相同的算法
- ✅ 确保输出字节级完全一致
- ✅ 测试验证与C版本100%一致

**理由**：
- 这是**学习项目**，目标是理解算法原理
- C版本已经实现了所有功能，证明可行
- 用库替代 = 跳过学习 = 违背项目目标

### 3. 调试流程

```
测试失败
    ↓
1. 查看 C 版本对应代码实现
    ↓
2. 对比数据结构、常量、算法
    ↓
3. 使用 Python/zlib 验证期望值
    ↓
4. 修复 Rust 实现
    ↓
5. 重新测试
```

## C 版本关键参考

| 模块 | C 代码位置 | Rust 代码位置 |
|-----|-----------|--------------|
| Adler32 | `mz_adler32()` (line 39) | `src/miniz/mod.rs::adler32()` |
| CRC32 | `mz_crc32()` (line 67) | `src/miniz/crc32.rs` |
| Huffman | DEFLATE Huffman 表 | `src/miniz/huffman.rs` |
| INFLATE | `tinfl_decompress()` (line 2790) | `src/miniz/inflate.rs` |
| DEFLATE | `tdefl_compress()` (line 1877) | `src/miniz/deflate.rs` |

## 验证工具

```bash
# Python zlib 验证 Adler32
python3 -c 'import zlib; print(f"0x{zlib.adler32(b\"Hello world!\", 1):08X}")'

# Python zlib 验证 DEFLATE
python3 -c 'import zlib; print(zlib.compress(b"Hello world!"))'

# C 版本测试（如果有）
cd ../ && R -e "zip::test()"
```

## 常见问题

| 问题 | 检查项 |
|-----|-------|
| Adler32 值不对 | 模 65521 的应用时机 |
| Huffman 解码失败 | 码长表是否与 RFC 1951 一致 |
| INFLATE 数据错误 | 位读取顺序（LSB 优先） |
| 测试期望值 | 用 C 版本或 Python 验证 |
